<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8">
  <link rel="stylesheet" type="text/css" href="/css/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/template.css" media="all">
  

  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="/css/ie7.css" media="all">
  <![endif]-->

  <script>
      var baseUrl = '';
      var pageFullPath = 'documentation/Android_extensions/11 Write_an_extension';
  </script>
  <script type="text/javascript" src="/javascript/jquery-1.7.2.min.js"></script>
  <script type="text/javascript" src="/javascript/mousetrap.min.js"></script>
  <script type="text/javascript" src="/javascript/gollum.js"></script>
  <script type="text/javascript" src="/javascript/gollum.dialog.js"></script>
  <script type="text/javascript" src="/javascript/gollum.placeholder.js"></script>
  <script type="text/javascript" src="/javascript/editor/gollum.editor.js"></script>

  

  <title>documentation/Android_extensions/11 Write_an_extension</title>
</head>
<body>

<script>
Mousetrap.bind(['e'], function( e ) {
  e.preventDefault();
  window.location = "/edit" + window.location.pathname;
  return false;
});
</script>
<div id="wiki-wrapper" class="page">
<div id="head">
  <h1>Write an extension</h1>
  <ul class="actions">
    <li class="minibutton">
      <div id="searchbar">
        <form action="/search" method="get" id="search-form">
        <div id="searchbar-fauxtext">
          <input type="text" name="q" id="search-query" value="Search&hellip;" autocomplete="off">
          <a href="#" id="search-submit" title="Search this wiki">
            <span>Search</span>
          </a>
        </div>
        </form>
      </div>    </li>
    <li class="minibutton"><a href="/"
       class="action-home-page">Home</a></li>
    <li class="minibutton"><a href="/pages"
      class="action-all-pages">All</a></li>
    <li class="minibutton"><a href="/fileview"
    class="action-fileview">Files</a></li>
    <li class="minibutton jaws">
      <a href="#" id="minibutton-new-page">New</a></li>
    <li class="minibutton jaws">
      <a href="#" id="minibutton-rename-page">Rename</a></li>
    <li class="minibutton"><a href="/edit/documentation/Android_extensions/11-Write_an_extension"
       class="action-edit-page">Edit</a></li>
    <li class="minibutton"><a href="/history/documentation/Android_extensions/11-Write_an_extension"
       class="action-page-history">History</a></li>
  </ul>
</div>
<div id="wiki-content">
<div class="">
  <div id="wiki-body" class="gollum-markdown-content">
    <div class="markdown-body">
      

<p>Crosswalk extensions are written in Java, and have access to the standard <a href="http://developer.android.com/reference/packages.html">Android APIs</a>.</p>

<p>In addition, because Crosswalk on Android acts as an <a href="http://developer.android.com/reference/android/app/Activity.html">Activity</a> and has access to a <a href="http://developer.android.com/reference/android/content/Context.html">Context</a>, an extension can make also use of those objects. However, the extension you'll develop in this tutorial doesn't use any Android APIs, as it only does simple string manipulation.</p>

<p>Even with the extensive Android APIs available to you, there may be some cases where you need to use other third-party libraries in your extension. This tutorial explains how to do this, with an example of using <a href="https://code.google.com/p/google-gson/">Gson</a> to read and write JSON. (While the Android API has some JSON capabilities, Gson is much neater and easier to use.)</p>

<h2>What does the extension do?<a class="anchor" id="What-does-the-extension-do?" href="#What-does-the-extension-do?"></a></h2>

<p>Here's an overview of how this extension works:</p>

<ol><li>
  When the Crosswalk application (with extension) starts on the Android device, an instance of the <code>Echo</code> extension is instantiated.
  </li>

  <li>
    <p>The web part of the application calls one of the methods exported by the JavaScript part of the extension; either <code>echo.echoAsync()</code> (asynchronous) or <code>echo.echo()</code> (synchronous). Both take a single argument, representing the message to echo.</p>

    <p>In both cases, the JavaScript part of the extension creates a message object with this structure:</p>

    <pre>
{
  "id": "1",
  "content": "Hello world"
}
    </pre>

    <p>Each message contains a unique request ID. This ID is used to ensure that the response is married up to the correct callback when the extension returns its results.</p>

    <p>This message object is serialised to JSON and sent to the Java part of the extension.</p>
  </li>

  <li>
    Inside the <code>Echo</code> instance (Java), the JSON string received from the JavaScript part of the extension is deserialised to a <code>Message</code> object.
  </li>

  <li>
    Next, the private <code>echo()</code> method of the <code>Echo</code> instance is invoked. Note that this method receives the request ID (from the JavaScript side). <code>echo()</code> simply prefixes the string it was passed and returns it.
  </li>

  <li>
    <p>The <code>Echo</code> instance then creates a <code>Message</code> object. This is serialised to a JSON string (via Gson) before being returned to the original caller.</p>

    <p>The JSON string is either returned immediately (synchronous) or posted back to the JavaScript side of the extension as a message (asynchronous).</p>
  </li>

  <li>
    <p><a name="message-data-structure" id="message-data-structure"></a>On the JavaScript side, the JSON string is deserialised into an object with this structure:</p>

    <pre>
{
  "id": "1",
  "content": "You said: Hello world"
}
    </pre>

    <p>The web application can do what it wants with the object; in this tutorial, it creates a DOM element containing the prefixed string held in the <code>content</code> property.</p>
  </li>
</ol><p>In the following sections, you'll create the Java and JavaScript sides of the extension and wire them together with a configuration file.</p>

<h2>Set up the directory structure<a class="anchor" id="Set-up-the-directory-structure" href="#Set-up-the-directory-structure"></a></h2>

<pre><code>cd ~/&lt;my projects directory&gt;/xwalk-echo-project

# top-level directory for extension code
mkdir xwalk-echo-extension-src
cd xwalk-echo-extension-src

# for the extension Java code; NB the Java classes
# will be in the package org.crosswalkproject.sample
# - adjust this for your own project
mkdir -p java/org/crosswalkproject/sample

# for extension JavaScript code
mkdir js

# for third party libs distributed with the project
mkdir tools
</code></pre>

<p>The <code>build/</code>, <code>lib/</code> and <code>xwalk-echo-extension/</code> directories (shown in the <a href="#documentation/android_extensions/host_and_target_setup/project_outline">project outline</a>) will be created at build time.</p>

<p>Note that the following instructions assume you're in <code>xwalk-echo-extension-src/</code> (the top-level directory for the extension project).</p>

<h2>Add Java code for the extension<a class="anchor" id="Add-Java-code-for-the-extension" href="#Add-Java-code-for-the-extension"></a></h2>

<p>First, create a Java class which extends <a href="https://github.com/crosswalk-project/crosswalk/blob/master/app/android/runtime_client/src/org/xwalk/app/runtime/extension/XWalkExtensionClient.java"><code>XWalkExtensionClient</code></a>.</p>

<p><strong><code>java/org/crosswalkproject/sample/Echo.java</code>:</strong></p>

<pre><code>package org.crosswalkproject.sample;

import org.xwalk.app.runtime.extension.XWalkExtensionClient;
import org.xwalk.app.runtime.extension.XWalkExtensionContextClient;
import com.google.gson.Gson;

public class Echo extends XWalkExtensionClient {
  private Gson gson = new Gson();

  public Echo(String name, String jsApiContent, XWalkExtensionContextClient xwalkContext) {
    super(name, jsApiContent, xwalkContext);
  }

  private String echo(String requestJson) {
    Message request = gson.fromJson(requestJson, Message.class);
    String reply = "You said: " + request.content;
    Message response = new Message(request.id, reply);
    return gson.toJson(response);
  }

  @Override
  public void onMessage(int instanceId, String requestJson) {
    postMessage(instanceId, echo(requestJson));
  }

  @Override
  public String onSyncMessage(int instanceId, String requestJson) {
    return echo(requestJson);
  }
}
</code></pre>

<p>The two key methods in this class are the ones which override the default <code>XWalkExtensionClient</code> methods. These provide the means for communicating between the JavaScript and Java parts of the extension:</p>

<ul><li>  <code>onMessage()</code>: For asynchronous messages.</li>
<li>  <code>onSyncMessage()</code>: For synchronous messages.</li>
</ul><p>Internally, both methods invoke the private <code>echo()</code> method, which:</p>

<ol><li> Deserialises the original request string to a <code>Message</code> object (see below).</li>
<li> Prefixes the content string (passed in the request) with "You said: ".</li>
<li> Creates a new <code>Message</code> object as the response, with the prefixed string and the original request ID.</li>
<li> Serialises it back to JSON.</li>
</ol><p>However, they return the result in different ways:</p>

<ul><li>  <code>onSyncMessage()</code> returns the JSON string directly to the calling JavaScript code.</li>
<li>  <code>onMessage()</code> indirectly returns the result by invoking <code>postMessage()</code> (a method on the <code>XWalkExtensionClient</code> class). This posts a JSON string back to the JavaScript side of the API asynchronously, where it can be handled by a listener.</li>
</ul><p>A supporting class is used to make these JSON operations easier, as shown below.</p>

<p><strong><code>java/org/crosswalkproject/sample/Message.java</code>:</strong></p>

<pre><code>package org.crosswalkproject.sample;

public class Message {
  public String id;
  public String content;

  public Message(String id, String content) {
    this.id = id;
    this.content = content;
  }
}
</code></pre>

<p>(Gson provides methods for serialising to and deserialising from Java objects, providing they have public member variables, as the <code>Message</code> class above does.)</p>

<p>Before you can build the extension, you will need to add the other required files, as explained below.</p>

<h2>Add the extension configuration file<a class="anchor" id="Add-the-extension-configuration-file" href="#Add-the-extension-configuration-file"></a></h2>

<p>The configuration file tells the Crosswalk packaging tool (<code>make_apk.py</code>) how the Java and JavaScript parts of the extension work together.</p>

<p>Create a JSON file <code>xwalk-echo-extension.json</code> with this content:</p>

<pre><code>{
  "name":  "echo",
  "class": "org.crosswalkproject.sample.Echo",
  "jsapi": "xwalk-echo-extension.js",
  "permissions": []
}
</code></pre>

<p>The properties in the object defined in this file have the following roles:</p>

<ul><li><p><code>name</code>: The extension's namespace, exposed to the web application's global scope. For example, as the namespace is <code>echo</code> for your extension, the web application can use it as follows:</p>

<pre><code>// async
echo.echoAsync("Hello world").then(
  function (result) {
    // ...process result...
  }
);

// sync
var message = echo.echo("Hello world");
</code></pre>

<p>Note that the web application doesn't have to import a JavaScript file: the extension's API is automatically made available in the global JavaScript scope when the extension is instantiated. The methods available on the API are the ones defined in the <code>xwalk-echo-extension.js</code> file you will create next.</p></li>
<li><p><code>class</code>: The Java class which implements the extension; in your case, the <code>org.crosswalkproject.sample.Echo</code> class. Note that this should include the package name as well as the class name.</p></li>
<li><p><code>jsapi</code>: The file which defines the JavaScript API. You will create this in the next section.</p></li>
<li><p><code>permissions</code>: A list of additional permissions required by the extension. It's included here for completeness, but is empty in this case as this extension only requires Crosswalk's default permissions. If you are writing your own application, you may need to add extra permissions.</p>

<p>The strings in the <code>permissions</code> array should match the corresponding Android permission; see the <a href="http://developer.android.com/reference/android/Manifest.permission.html">list of Android permissions</a> for details. For example, if you needed access to the <code>FLASHLIGHT</code> and <code>GET_ACCOUNTS</code> permissions, your extension configuration file would have a <code>permissions</code> property like this:</p>

<pre><code>"permissions": ["android.permission.FLASHLIGHT", "android.permission.GET_ACCOUNTS"]
</code></pre></li>
</ul><p>At build time, <code>make_apk.py</code> will combine this JSON file with configuration files for other extensions into a single <code>extensions-config.json</code> file. This is the file that Crosswalk actually uses to load the extension class and its corresponding JavaScript API.</p>

<h2>Add the JavaScript API file<a class="anchor" id="Add-the-JavaScript-API-file" href="#Add-the-JavaScript-API-file"></a></h2>

<p>Create <code>js/xwalk-echo-extension.js</code> with this content:</p>

<pre><code>/*
echoAsync() and echo() resolve to/return an object (respectively)
with the form:

{
  id: '&lt;request ID&gt;',
  content: '&lt;content of reply from Java extension code&gt;'
}
*/

// provides a unique ID for each call to the extension
var counter = 0;

// map from a request ID to a callback for the response
var successCbs = {};

// private method for building the message object and converting it
// to a JSON string for transfer to the Java part of the extension
var messageToJson = function (counter, message) {
  var obj = {
    id: '' + counter,
    content: message
  };

  return JSON.stringify(obj);
};

// message listener for ALL messages; this invokes the correct
// callback depending on the ID in the message
extension.setMessageListener(function (message) {
  var data = JSON.parse(message);
  var cb = successCbs[data.id];

  if (cb) {
    cb(data);
    delete successCbs[data.id];
  }
});

// returns a promise which resolves to an array of file objects, or
// rejects with an error if the call to the extension fails
exports.echoAsync = function (message) {
  counter += 1;
  var messageJson = messageToJson(counter, message);

  return new Promise(function (resolve, reject) {
    successCbs[counter] = resolve;

    // NB you MUST pass a string to postMessage()
    try {
      extension.postMessage(messageJson);
    }
    catch (e) {
      reject(e);
    }
  });
};

// returns a Response object
exports.echo = function (message) {
  counter += 1;
  var messageJson = messageToJson(counter, message);

  // NB you MUST pass a string to sendSyncMessage()
  var result = extension.internal.sendSyncMessage(messageJson);

  return JSON.parse(result);
};
</code></pre>

<p>A few notes on the content of this file:</p>

<ul><li><p>The <code>counter</code> variable is incremented and passed as the request ID each time a call is made to the <code>postMessage()</code> method in the Java part of the extension. This is so that any messages returning from the extension can be married up to a corresponding callback. The counter is also passed to the <code>sendSyncMessage()</code> method for the sake of consistency (the Java part of the extension always receives a JSON string with an <code>id</code> and <code>content</code>); this is despite the fact that there's no need to coordinate synchronous method calls with callbacks (as the result is returned immediately).</p></li>
<li><p>When <code>echoAsync()</code> is invoked, a new Promise is created (see the next section). The function for handling a successful resolution of the Promise (<code>resolve</code>) is associated with the unique ID for this request by adding it to <code>successCbs</code>.</p></li>
<li><p><code>extension.setMessageListener()</code> sets a function to invoke for each message returned by the Java side of the extension. This function will be invoked for <em>every</em> message; but the handlers which will actually deal with the data are stored in the <code>successCbs</code> object: a map from request IDs to handlers. When a message is received, the correct handler is looked up from <code>successCbs</code> and invoked with the message as an argument. The handler is deleted from the <code>successCbs</code> object after it has been invoked.</p></li>
<li><p>Any properties (methods/objects/constants etc.) you want to expose as the JavaScript API for your extension should be appended to the <code>exports</code> object inside the JavaScript API file. This has a similar role to the <code>exports</code> object in nodejs modules, defining the public face of the API. Any other variables <em>not</em> attached to <code>exports</code> are only scoped to this file, and won't pollute the web application's global scope.</p>

<p>The namespace the JavaScript API is exported to here (<code>echo</code>) is set in the extension configuration file, <code>xwalk-echo-extension.json</code>, which you created in the previous section.</p></li>
<li><p>The Java side of the extension is available via the <code>extension</code> object. Note that the code above invokes the <code>extension.internal.sendSyncMessage()</code> and <code>extension.postMessage()</code> functions, which communicate with the Java code you wrote earlier.</p></li>
</ul><h3>Promises, promises<a class="anchor" id="Promises,-promises" href="#Promises,-promises"></a></h3>

<p>The synchronous method defined for the extension's JavaScript API (<code>echo()</code>) is straightforward, and has this signature:</p>

<pre><code>echo.echo() : Message
</code></pre>

<p>where <code>Message</code> has the shape described <a href="#message-data-structure">here</a>.</p>

<p>By contrast, the asynchronous <code>echoAsync()</code> method has this signature:</p>

<pre><code>echo.echoAsync() : Promise
</code></pre>

<p>If you're not familiar with <a href="http://promises-aplus.github.io/promises-spec/">Promises</a> (a relatively recent addition to the web application developer's toolkit), this might look odd. Why not just use callbacks? For example, replace the Promise-returning method with an async method which has this signature:</p>

<pre><code>echo.echoAsync(callback) : undefined
</code></pre>

<p>and call <code>callback(message)</code> when the Java side of the API returns its <code>Message</code> object (serialised to JSON).</p>

<p>The problem with callbacks is that they have to be managed carefully: if callbacks are nested inside callbacks inside  callbacks etc., it can lead to the so-called <a href="http://survivejs.com/common_problems/pyramid.html">pyramid of doom</a>. For example, imagine that you wanted to do some additional work on the response to set extra properties on it. You might have a couple of objects to do this, and invoke their methods once the initial result is passed to the callback:</p>

<pre><code>echo.echoAsync(function (result) {

  // decorate result with more properties
  decorator1.decorate(result, function (decoratedResult) {

    // decorate decoratedResult with even more properties
    decorator2.decorate(decoratedResult, function (evenMoreDecoratedResult) {
      displayData(evenMoreDecoratedResult);
    });

  });

});
</code></pre>

<p>In the code sample above, there are calls to two asynchronous functions, <code>decorator1.decorate()</code> and <code>decorator2.decorate()</code>, which decorate the response with additional properties. Note how the pyramid is already starting to emerge. Adding yet more decorators could make it even worse.</p>

<p>There are other ways to avoid the pyramid emerging here; but the point of using Promises is to codify those approaches with extra sugar on top, to simplify asynchronous code and avoid nested callbacks. For example, if <code>echoAsync()</code> returns a Promise, and the <code>*.decorate()</code> methods also return Promises, we could instead use this code:</p>

<pre><code>echo.echoAsync()
.then(
  function (result) {
    return decorator1.decorate(result);
  }
)
.then(
  function (decoratedResult) {
    return decorator2.decorate(decoratedResult);
  }
)
.then(displayData);
</code></pre>

<p>The <code>then()</code> method takes a function to apply to the value returned by the Promise when it is <em>resolved</em> (i.e. it successfully completes its asynchronous operation and "becomes" a value which is not an error). It can also optionally take a method to apply to any errors returned by the Promise if it is <em>rejected</em> (i.e. it fails in some way and "becomes" an error).</p>

<p>You can see that the pyramid effect has been avoided, and it's much clearer which processing steps are being applied to the data when.</p>

<p>Note that in the last <code>then()</code> call, because we're not returning anything, we can just pass the <code>displayData</code> function and the result of <code>decorator2.decorate()</code> will be implicitly passed to that method.</p>

<p>In many environments, Promises are not natively available; the typical solution is to incorporate a library like <a href="http://documentup.com/kriskowal/q/">Q</a> to fill the gap. By contrast, in Crosswalk, you <em>do</em> have native access to Promises, which is what you're using in the JavaScript side of the extension (above); so there's less need for an external library.</p>

<h2>Add build infrastructure<a class="anchor" id="Add-build-infrastructure" href="#Add-build-infrastructure"></a></h2>

<p>To use an extension in a Crosswalk application, you have to include it in the Android package for your application. The Crosswalk packaging tool has stringent requirements about how an extension should be structured to be included in a package. The layout of the extension <em>must</em> be like this:</p>

<pre><code>myextension/
  myextension.jar
  myextension.js
  myextension.json
</code></pre>

<p>All of the names <em>must</em> match: the directory name must match the prefix of the <code>.jar</code>, <code>.js</code> and <code>.json</code> files, otherwise the extension won't be included in the package.</p>

<p>You would replace "myextension" with your extension's name. For the extension in this tutorial, the layout you need is:</p>

<pre><code>xwalk-echo-extension/
  xwalk-echo-extension.jar
  xwalk-echo-extension.js
  xwalk-echo-extension.json
</code></pre>

<p>However, you may notice that the files you have so far don't match this layout (e.g. the <code>xwalk-echo-extension.js</code> is in a <code>js</code> directory and you don't have a <code>.jar</code> file at all). This is where the build infrastructure comes in. Rather than manually create these files and place them in the right directory, you'll set up an automatic build which will create a temporary <code>xwalk-echo-extension</code> directory and copy/compile the three required files into it.</p>

<p>Ivy and Ant are common tools for working with Java projects, so you'll use them to build the extension: Ivy to download the Gson jar file at build time (as <code>Echo</code> depends on it); and Ant to compile the Java code for the extension and copy files to the required locations. (If you are familiar with Eclipse, it's possible to use that as well as, or instead of, command-line tools.)</p>

<p>The next two sections explain how to set up Ivy and Ant.</p>

<h3>Set up and configure Ivy<a class="anchor" id="Set-up-and-configure-Ivy" href="#Set-up-and-configure-Ivy"></a></h3>

<p>Follow the instructions below to install and configure Ivy:</p>

<ol><li><p>Download the Apache Ivy distribution, which contains the Ivy tasks for Ant. It's available from <a href="https://ant.apache.org/ivy/download.cgi">the Apache Ivy download site</a>. For example, to get Ivy 2.4.0-rc1:</p>

<pre><code>$ wget http://www.mirrorservice.org/sites/ftp.apache.org/ant/ivy/2.4.0-rc1/apache-ivy-2.4.0-rc1-bin.zip
</code></pre></li>
<li><p>Unpack it and copy the Ivy jar file to the <code>tools/</code> directory:</p>

<pre><code>$ unzip apache-ivy-2.4.0-rc1-bin.zip
$ cp apache-ivy-2.4.0-rc1/ivy-2.4.0-rc1.jar tools/
</code></pre>

<p>You can remove the zip file once you're done with it.</p></li>
<li><p>Add the Ivy configuration file, <code>ivy.xml</code>, to the top-level directory:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ivy-module version="2.3"&gt;
  &lt;info organisation="org.crosswalkproject.sample" module="xwalk-echo-extension" /&gt;
  &lt;dependencies&gt;
    &lt;dependency org="com.google.code.gson"
                name="gson"
                rev="2.2.4"
                conf="default-&gt;master" /&gt;
  &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>

<p>You only have one dependency here (<code>gson.jar</code>), but you could add other third-party libraries to this file.</p>

<p>Note that Crosswalk is not in the Ivy repositories, and will be downloaded by Ant in the main buildfile.</p></li>
</ol><h3>Add an Ant buildfile<a class="anchor" id="Add-an-Ant-buildfile" href="#Add-an-Ant-buildfile"></a></h3>

<p>You should have already installed Ant as described in the <em>Getting started</em> instructions (<a href="#documentation/getting_started/windows_host_setup/Install-Ant">Windows</a>, <a href="#documentation/getting_started/linux_host_setup/Install-Ant">Linux</a>).</p>

<p>Once Ant is installed, add a buildfile, <code>build.xml</code>, to the top-level directory of your project with this content:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns:ivy="antlib:org.apache.ivy.ant" name="xwalk-echo-extension" default="dist"&gt;
  &lt;!-- Java source --&gt;
  &lt;property name="src" value="java" /&gt;

  &lt;!-- downloaded third party libraries --&gt;
  &lt;property name="lib" value="lib" /&gt;

  &lt;!-- Crosswalk Android version --&gt;
  &lt;property name="crosswalk-version" value="${XWALK-STABLE-ANDROID-X86}" /&gt;

  &lt;!-- URL of Crosswalk Android bundle --&gt;
  &lt;property name="crosswalk-download-url"
            value="https://download.01.org/crosswalk/releases/crosswalk/android/stable/${crosswalk-version}/crosswalk-${crosswalk-version}.zip" /&gt;

  &lt;!-- location of downloaded Crosswalk Android file --&gt;
  &lt;property name="crosswalk-zip" value="${lib}/crosswalk.zip" /&gt;

  &lt;!-- temporary build directory --&gt;
  &lt;property name="build" value="build" /&gt;

  &lt;!-- final location for the built extension --&gt;
  &lt;property name="dist" value="xwalk-echo-extension" /&gt;

  &lt;!-- classpath containing the Ivy Ant tasks jar file --&gt;
  &lt;path id="ivy.lib.path"&gt;
    &lt;fileset dir="tools" includes="*.jar"/&gt;
  &lt;/path&gt;

  &lt;!-- delete + make the temporary build directories --&gt;
  &lt;target name="prepare"&gt;
    &lt;delete dir="${build}" quiet="true" /&gt;
    &lt;delete dir="${dist}" quiet="true" /&gt;

    &lt;mkdir dir="${build}" /&gt;
    &lt;mkdir dir="${lib}" /&gt;
    &lt;mkdir dir="${dist}" /&gt;
  &lt;/target&gt;

  &lt;!-- download dependencies using Ivy --&gt;
  &lt;target name="download-deps" depends="prepare"&gt;
    &lt;taskdef resource="org/apache/ivy/ant/antlib.xml"
             uri="antlib:org.apache.ivy.ant"
             classpathref="ivy.lib.path" /&gt;
    &lt;ivy:retrieve pattern="${lib}/[artifact]-[revision].[ext]" /&gt;
  &lt;/target&gt;

  &lt;!-- check whether the Crosswalk zip file is present --&gt;
  &lt;target name="check-crosswalk-present" depends="prepare"&gt;
    &lt;available file="${crosswalk-zip}" property="crosswalk-zip.present"/&gt;
  &lt;/target&gt;

  &lt;!-- manually get crosswalk.zip if it's not already there --&gt;
  &lt;target name="download-crosswalk" depends="prepare, check-crosswalk-present"
          unless="crosswalk-zip.present"&gt;
    &lt;!-- fetch from the download site --&gt;
    &lt;get src="${crosswalk-download-url}" dest="${crosswalk-zip}" /&gt;

    &lt;!-- unpack to lib/crosswalk-*/ --&gt;
    &lt;unzip src="${crosswalk-zip}" dest="${lib}" /&gt;
  &lt;/target&gt;

  &lt;!-- compile the extension Java code --&gt;
  &lt;target name="compile" depends="download-deps, download-crosswalk"&gt;
    &lt;javac srcdir="${src}" destdir="${build}"
           encoding="utf-8" debug="true" verbose="true"&gt;
      &lt;classpath&gt;
        &lt;fileset dir="${lib}" includes="*.jar" /&gt;
        &lt;file file="${lib}/crosswalk-${crosswalk-version}/libs/xwalk_app_runtime_java.jar" /&gt;
      &lt;/classpath&gt;
    &lt;/javac&gt;
  &lt;/target&gt;

  &lt;!--
  pack third party Java code and extension code into a single
  jar, and copy supporting files to the xwalk-echo-extension/
  directory; NB we don't need to pack any Crosswalk jars, as they
  will be added by the packaging tool; and we don't need android.jar,
  as that is on the Android target already
  --&gt;
  &lt;target name="dist" depends="compile"&gt;
    &lt;unjar dest="${build}"&gt;
      &lt;fileset dir="${lib}"&gt;
        &lt;include name="*.jar" /&gt;
      &lt;/fileset&gt;
    &lt;/unjar&gt;

    &lt;jar destfile="${dist}/xwalk-echo-extension.jar"&gt;
      &lt;fileset dir="${build}" excludes="META-INF/**" /&gt;
    &lt;/jar&gt;

    &lt;copy file="xwalk-echo-extension.json" todir="${dist}" /&gt;
    &lt;copy file="js/xwalk-echo-extension.js" todir="${dist}" /&gt;
  &lt;/target&gt;
&lt;/project&gt;
</code></pre>

<p>This is a fairly standard Ant buildfile for a small project. The default task is <code>dist</code>, which does the following:</p>

<ol><li>Deletes and recreates the <code>build/</code> and <code>xwalk-echo-extension/</code> directories.</li>

  <li>Downloads the Gson jar file dependency and puts it in the <code>lib/</code> directory (via Ivy).</li>

  <li>Downloads Crosswalk Android (via HTTP) and unpacks it in the <code>lib/</code> directory. Note that if you want to use the <a href="#documentation/downloads">beta or canary versions of Crosswalk</a>, you will need to modify the <code>crosswalk-version</code> and <code>crosswalk-download-url</code> <code>&lt;property&gt;</code> elements as follows:

    <ul><li>
        <p><strong>beta:</strong></p>

        <pre>
&lt;property name="crosswalk-version" value="${XWALK-BETA-ANDROID-X86}" /&gt;

&lt;property name="crosswalk-download-url"
          value="https://download.01.org/crosswalk/releases/crosswalk/android/beta/${crosswalk-version}/crosswalk-${crosswalk-version}.zip" /&gt;
        </pre>
      </li>

      <li>
        <p><strong>canary:</strong></p>

        <pre>
&lt;property name="crosswalk-version" value="...Crosswalk canary version..." /&gt;

&lt;property name="crosswalk-download-url"
          value="https://download.01.org/crosswalk/releases/crosswalk/android/canary/${crosswalk-version}/crosswalk-${crosswalk-version}.zip" /&gt;
        </pre>

        <p>You can find the current canary version by consulting the <a href="#documentation/downloads">downloads page</a>.</p>
      </li>
    </ul></li>

  <li>Compiles the extension Java source in the <code>src/</code> directory, placing the output <code>.class</code> files into the <code>build/</code> directory.</li>

  <li>Unpacks the Gson jar file into the <code>build/</code> directory. This is so it can be included in the extension jar file.</li>

  <li>Creates a jar file in <code>xwalk-echo-extension/</code> containing the extension <code>.class</code> files and the content unpacked from the Gson jar file.</li>

  <li>Copies the extension JSON configuration <code>xwalk-echo-extension.json</code> and the JavaScript API definition <code>js/xwalk-echo-extension.js</code> into the <code>xwalk-echo-extension/</code> directory.</li>

</ol><p>The final output of this task, the <code>xwalk-echo-extension/</code> directory, contains an extension with the correct layout to be included in a Crosswalk <code>.apk</code> file, i.e.</p>

<pre><code>xwalk-echo-extension/
  xwalk-echo-extension.jar
  xwalk-echo-extension.js
  xwalk-echo-extension.json
</code></pre>

<h2>Build the extension<a class="anchor" id="Build-the-extension" href="#Build-the-extension"></a></h2>

<p>As you added a standard Ant buildfile, building the extension is as simple as running this command in the <code>xwalk-echo-extension-src/</code> directory:</p>

<pre><code>$ ant
</code></pre>

<p>This runs the default <code>dist</code> task (see above). (It may take a while the first time, as it will download the third party dependencies.)</p>

<p>Once the extension is built, the next step is to create the web application which can use it.</p>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>Elliot Smith</b>, 2014-08-19 16:39:08</p>
  <p>
    <a id="delete-link" href="/documentation/Android_extensions/11-Write_an_extension" data-confirm="Are you sure you want to delete this page?"><span>Delete this Page</span></a>
  </p>
</div>
</div>

<form name="rename" method="POST" action="/rename/documentation/Android_extensions/11-Write_an_extension">
  <input type="hidden" name="rename"/>
  <input type="hidden" name="message"/>
</form>


</body>
</html>
