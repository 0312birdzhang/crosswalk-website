<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-type" content="text/html;charset=utf-8">
  <link rel="stylesheet" type="text/css" href="/css/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="/css/template.css" media="all">
  

  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="/css/ie7.css" media="all">
  <![endif]-->

  <script>
      var baseUrl = '';
      var pageFullPath = 'documentation/Tizen_IVI_extensions/15 Write_an_extension_in_C';
  </script>
  <script type="text/javascript" src="/javascript/jquery-1.7.2.min.js"></script>
  <script type="text/javascript" src="/javascript/mousetrap.min.js"></script>
  <script type="text/javascript" src="/javascript/gollum.js"></script>
  <script type="text/javascript" src="/javascript/gollum.dialog.js"></script>
  <script type="text/javascript" src="/javascript/gollum.placeholder.js"></script>
  <script type="text/javascript" src="/javascript/editor/gollum.editor.js"></script>

  

  <title>documentation/Tizen_IVI_extensions/15 Write_an_extension_in_C</title>
</head>
<body>

<script>
Mousetrap.bind(['e'], function( e ) {
  e.preventDefault();
  window.location = "/edit" + window.location.pathname;
  return false;
});
</script>
<div id="wiki-wrapper" class="page">
<div id="head">
  <h1>Write an extension in C</h1>
  <ul class="actions">
    <li class="minibutton">
      <div id="searchbar">
        <form action="/search" method="get" id="search-form">
        <div id="searchbar-fauxtext">
          <input type="text" name="q" id="search-query" value="Search&hellip;" autocomplete="off">
          <a href="#" id="search-submit" title="Search this wiki">
            <span>Search</span>
          </a>
        </div>
        </form>
      </div>    </li>
    <li class="minibutton"><a href="/"
       class="action-home-page">Home</a></li>
    <li class="minibutton"><a href="/pages"
      class="action-all-pages">All</a></li>
    <li class="minibutton"><a href="/fileview"
    class="action-fileview">Files</a></li>
    <li class="minibutton jaws">
      <a href="#" id="minibutton-new-page">New</a></li>
    <li class="minibutton jaws">
      <a href="#" id="minibutton-rename-page">Rename</a></li>
    <li class="minibutton"><a href="/edit/documentation/Tizen_IVI_extensions/15-Write_an_extension_in_C"
       class="action-edit-page">Edit</a></li>
    <li class="minibutton"><a href="/history/documentation/Tizen_IVI_extensions/15-Write_an_extension_in_C"
       class="action-page-history">History</a></li>
  </ul>
</div>
<div id="wiki-content">
<div class="">
  <div id="wiki-body" class="gollum-markdown-content">
    <div class="markdown-body">
      

<p>In this section, you will write, build and package the Crosswalk extension. The extension itself is written in C and built using <code>make</code>. For packaging, you'll use the Tizen IVI <code>gbs</code> tool, which can build an <a href="http://rpm.org/">rpm file</a> for a make-enabled project (rpm is the packaging format used by Tizen IVI).</p>

<p>Although you are creating the extension and the application alongside each other in this tutorial, they are actually two separate pieces: one extension can be used to support multiple applications if desired.</p>

<p>The extension consists of three parts:</p>

<ol><li><p>A JavaScript file. This defines the API which web applications can invoke.</p></li>
<li><p>A C header file containing a "stringified" version of the JavaScript file. This is used to define the JavaScript API for the extension inside the C program. This file is generated at build-time, before the C library is compiled.</p></li>
<li><p>The C file which implements the native side of the extension.</p></li>
</ol><p>You also need some supporting files to build and package the extension.</p>

<p>Before starting, make sure you have already followed the steps in <a href="#documentation/Tizen_IVI_extensions/Host_and_target_setup">Host and target setup</a>.</p>

<h2>Create project files and directories<a class="anchor" id="Create-project-files-and-directories" href="#Create-project-files-and-directories"></a></h2>

<p>The first step is to set up the basic project directories and include the Crosswalk headers (for compiling the code).</p>

<p>Put the extension in an <code>echo-extension</code> directory with these commands:</p>

<pre><code>&gt; mkdir echo-extension
&gt; cd echo-extension

# directory for the Crosswalk extension source
&gt; mkdir extension

# directory for the packaging specification file
&gt; mkdir packaging

# directory for Crosswalk headers
&gt; mkdir common

# initialise the directory as a git repository (see below)
&gt; git init .
</code></pre>

<p>Because you'll be using gbs to build the rpm file for your extension, you need to make your project into a git repository (gbs won't work on plain directories).</p>

<h3>Include Crosswalk headers<a class="anchor" id="Include-Crosswalk-headers" href="#Include-Crosswalk-headers"></a></h3>

<p>You will need a copy of the Crosswalk headers, to compile your extension against:</p>

<ol><li><p>Checkout the Crosswalk github repo on the host machine (the machine where you intend to compile your extension):</p>

<pre><code>git clone https://github.com/crosswalk-project/crosswalk ~/crosswalk-source
</code></pre></li>
<li><p>Copy the Crosswalk headers for extensions into the <code>common</code> directory in your project:</p>

<pre><code>cp ~/crosswalk-source/src/xwalk/extensions/public/*.h echo-extension/common/
</code></pre></li>
</ol><h3>JavaScript bridge API to the C extension<a class="anchor" id="JavaScript-bridge-API-to-the-C-extension" href="#JavaScript-bridge-API-to-the-C-extension"></a></h3>

<p>This file wires the C interface to JavaScript and provides the bridge between the HTML5 application and the C code.</p>

<p>Note that it's not essential to maintain the JavaScript in a separate file: you can just add the JavaScript API inline to your C code. However, for purposes of maintainability, it makes sense to maintain the JavaScript API in its own file.</p>

<p>Add a file at <code>extension/api.js</code> with this content:</p>

<pre><code>var echoListener = null;

extension.setMessageListener(function(msg) {
  if (echoListener instanceof Function) {
    echoListener(msg);
  };
});

exports.echoAsync = function (msg, callback) {
  echoListener = callback;
  extension.postMessage(msg);
};

exports.echoSync = function (msg) {
  return extension.internal.sendSyncMessage(msg);
};
</code></pre>

<p>This JavaScript file is converted into a C header file at build-time; that header file is then referenced from the extension code. This is the simplest way to incorporate the JavaScript code into the C extension. See <a href="#documentation/tizen_ivi_extensions/build_an_application/C-header-file-for-the-JavaScript-API">this section</a> for details of how the conversion happens.</p>

<h4>A note on the JavaScript API<a class="anchor" id="A-note-on-the-JavaScript-API" href="#A-note-on-the-JavaScript-API"></a></h4>

<p>Note that the asynchronous part of this API is <em>not suitable</em> for a real production environment.</p>

<p>At the moment, when you invoke the <code>echoAsync()</code> method, you set a single global message listener: a function which waits for the next response to be returned by the C part of the extension. However, this approach would not work correctly if the processing which occurred in the extension took some time, and the <code>echoAsync()</code> method were invoked during that processing time.</p>

<p>For example, consider the following program:</p>

<pre><code>var callback1 = function (response) {
  console.log(response + ' world');
};

var callback2 = function (response) {
  console.log(response + ' cruel world');
};

// invocation 1
echo.echoAsync('hello', callback1);

// invocation 2
echo.echoAsync('goodbye', callback2);
</code></pre>

<p>When invocation 1 occurs, the message listener is set to <code>callback1</code>. If the extension takes several seconds to respond, invocation 2 may have already happened before invocation 1 completes; and invocation 2 sets the message listener to <code>callback2</code> (there is only one listener for all responses). Consequently, when invocation 1 does eventually return, its handler (<code>callback1</code>) has been overwritten; so the responses for both invocation 1 and invocation 2 will be (incorrectly) handled by <code>callback2</code>.</p>

<p>In practice, this means that you would see this on the console:</p>

<pre><code>hello cruel world
goodbye cruel world
</code></pre>

<p>instead of the anticipated:</p>

<pre><code>hello world
goodbye cruel world
</code></pre>

<p>The solution is to pass a token from the JavaScript API to the C code, then return that token as part of the response from the C code. The JavaScript API would maintain a mapping from tokens to callbacks, so when responses are returned (containing a token), the correct handler can be looked up and invoked. A typical way to implement this would be to JSON-encode messages between the JavaScript and C parts of the extension, and include a token in each message. However, this process is too complex for the scope of this tutorial.</p>

<p>If you're interested in seeing a real world example of how this would be implemented, the <a href="https://github.com/crosswalk-project/tizen-extensions-crosswalk">Crosswalk Tizen extensions</a> are a good place to start, e.g. <a href="https://github.com/crosswalk-project/tizen-extensions-crosswalk/blob/master/application/application_api.js">the application API JavaScript file</a>.</p>

<h3>C header file for the JavaScript API<a class="anchor" id="C-header-file-for-the-JavaScript-API" href="#C-header-file-for-the-JavaScript-API"></a></h3>

<p>The header file, <code>extension/echo-extension.h</code>, is a generated file which looks like this:</p>

<pre><code>static const char* kSource_echo_api = "var echoListener = null;"
""
"extension.setMessageListener(function(msg) {"
"  if (echoListener instanceof Function) {"
"    echoListener(msg);"
"  };"
"});"
""
"exports.echoAsync = function (msg, callback) {"
"  echoListener = callback;"
"  extension.postMessage(msg);"
"};"
""
"exports.echoSync = function (msg) {"
"  return extension.internal.sendSyncMessage(msg);"
"};"
;
</code></pre>

<p>By including this header file in a C file, you can access the <code>kSource_echo_api</code> constant, which defines the JavaScript API for the extension.</p>

<p>Note that this mirrors the JavaScript file you created earlier, but is generated by a script (in the root directory of the project). Create a file called <code>js2c.sh</code> in the root of the <strong>echo-extension</strong> project, with this content:</p>

<pre><code>#!/bin/sh
INPUT=${1:-/dev/stdin}
[ "$INPUT" = "-" ] &amp;&amp; INPUT="/dev/stdin"
OUTPUT=${2:-/dev/stdout}
[ "$OUT" = "-" ] &amp;&amp; OUT="/dev/stdout"

if [ ! -r "$INPUT" ] ; then
  echo "Usage: $(basename $0) [js api file] [output c header file]"
  exit 1
fi

exec &gt; $OUTPUT

echo "static const char* kSource_echo_api = "
tr -d '\r' &lt; "$INPUT" | sed 's:["\\]:\\&amp;:g;s:.*:    "&amp;\\n":'
echo ";"
</code></pre>

<p>You should make the script executable once you've created it with:</p>

<pre><code>chmod +x js2c.sh
</code></pre>

<p>Invoke it like this:</p>

<pre><code>./js2c.sh &lt;.js file&gt; &lt;output .h file&gt;
</code></pre>

<p>While the script can be invoked manually for testing, the aim is to incorporate it into an automated build later.</p>

<h3>C program code<a class="anchor" id="C-program-code" href="#C-program-code"></a></h3>

<p>This implements the Crosswalk extension API and has access to the full Tizen native API. For the purposes of this tutorial, the C code simply prefixes a message string with "You said: " and returns it.</p>

<p>Create a file <code>extension/echo-extension.c</code> with this content:</p>

<pre><code>// echo extension for Crosswalk Tizen
// adapted from
// https://github.com/crosswalk-project/crosswalk/blob/master/extensions/test/echo_extension.c
// Copyright (c) 2013 Intel Corporation. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "XW_Extension.h"
#include "XW_Extension_SyncMessage.h"

// load kSource_echo_api string to set JavaScript API;
// echo-extension.h is generated by the makefile at build time
#include "echo-extension.h"

static const char* echo_ext_response_prefix = "You said: ";

static XW_Extension g_extension = 0;
static const XW_CoreInterface* g_core = NULL;
static const XW_MessagingInterface* g_messaging = NULL;
static const XW_Internal_SyncMessagingInterface* g_sync_messaging = NULL;

static void instance_created(XW_Instance instance) {
  printf("Instance %d created!\n", instance);
}

static void instance_destroyed(XW_Instance instance) {
  printf("Instance %d destroyed!\n", instance);
}

// add a "You said: " prefix to message
static char* build_response(const char* message) {
  int length = strlen(echo_ext_response_prefix) +
               strlen(message);
  char* response = malloc(length);
  strcpy(response, echo_ext_response_prefix);
  strcat(response, message);
  return response;
}

static void handle_message(XW_Instance instance, const char* message) {
  char* response = build_response(message);
  g_messaging-&gt;PostMessage(instance, response);
  free(response);
}

static void handle_sync_message(XW_Instance instance, const char* message) {
  char* response = build_response(message);
  g_sync_messaging-&gt;SetSyncReply(instance, response);
  free(response);
}

static void shutdown(XW_Extension extension) {
  printf("Shutdown\n");
}

// this is the only function which needs to be public
int32_t XW_Initialize(XW_Extension extension, XW_GetInterface get_interface) {
  // set up the extension
  g_extension = extension;
  g_core = get_interface(XW_CORE_INTERFACE);
  g_core-&gt;SetExtensionName(extension, "echo");

  // kSource_echo_api comes from the echo-extension.h
  // header file
  g_core-&gt;SetJavaScriptAPI(extension, kSource_echo_api);

  g_core-&gt;RegisterInstanceCallbacks(
    extension, instance_created, instance_destroyed);
  g_core-&gt;RegisterShutdownCallback(extension, shutdown);

  g_messaging = get_interface(XW_MESSAGING_INTERFACE);
  g_messaging-&gt;Register(extension, handle_message);

  g_sync_messaging = get_interface(XW_INTERNAL_SYNC_MESSAGING_INTERFACE);
  g_sync_messaging-&gt;Register(extension, handle_sync_message);

  return XW_OK;
}
</code></pre>

<p>Some notes on the code:</p>

<ul><li><p>The <a href="https://github.com/crosswalk-project/crosswalk/blob/master/extensions/public/XW_Extension.h">XW_Extension.h</a> header is used to define the structures used by the extension system.</p></li>
<li><p>The only symbol that should be exported is the function:</p>

<pre><code>int32_t XW_Initialize(XW_Extension extension, XW_GetInterface get_interface)
</code></pre>

<p>Its parameters are:</p>

<ul><li>  <code>extension</code>: The identifier for this extension. This identifier will be used for the extension</li>
<li>  <code>get_interface</code>: A function with signature <code>const void* XW_GetInterface(const char* interface_name)</code> used for accessing the interfaces provided for integrating native code with the Crosswalk runtime. For each <code>interface_name</code>, it returns a pointer to a structure with functions that the extension can call.</li>
</ul><p>This function should be implemented and exported in the shared object; and it should return <code>XW_OK</code> when the extension is correctly initialized.</p>

<p>Be sure to use <code>extern "C"</code> when defining this function to avoid name mangling if using a C++ compiler (you're not in this tutorial).</p></li>
<li><p><code>SetExtensionName()</code> sets the public name for the JavaScript API which will be available to your web application.</p></li>
<li><p><code>SetJavaScriptAPI()</code> takes a JavaScript string to be presented as the API. The name you set with <code>SetExtensionName()</code> should match the one you use in the JavaScript API string. In the case of this extension, the API string is loaded from a header file which is generated by the build.</p></li>
<li><p>This example provides synchronous and asynchronous versions of the same handler. But an extension doesn't have to handle both synchronous and asynchronous messages: it can handle only one type if desired.</p>

<p>You should use asynchronous messaging where the processing performed by the C extension is likely to take some time (i.e. more than a few milliseconds; usually, this means anything involving disk or network access). Where the C code will return quickly (perhaps tens of milliseconds), synchronous messaging is safe enough.</p>

<p>However, in most cases, the safest approach is to provide an asynchronous API. The synchronous alternative is shown here for the sake of completeness.</p></li>
<li><p>Both the sync (<code>XW_Internal_SyncMessagingInterface-&gt;SetSyncReply()</code>) and async (<code>XW_MessagingInterface-&gt;PostMessage()</code>) functions for returning a response "preserve their inputs", so you can free any pointers you pass to those functions once you've invoked them.</p></li>
</ul><h4>More details on the C interfaces<a class="anchor" id="More-details-on-the-C-interfaces" href="#More-details-on-the-C-interfaces"></a></h4>

<ul><li><p>Core interface: <code>XW_CORE_INTERFACE</code></p>

<p>This interface is defined in the <a href="https://github.com/crosswalk-project/crosswalk/blob/master/extensions/public/XW_Extension.h">XW_Extension.h</a> header file.</p>

<p>It is a <code>struct XW_CoreInterface</code> with the following fields:</p>

<ul><li>  <code>SetExtensionName()</code> sets name of the extension (identified by <code>extension</code>) to <code>name</code>. This is mandatory. It should only be called during <code>XW_Initialize()</code>.</li>
<li>  <code>SetJavaScriptAPI()</code> exports the JavaScript shim that will be available to all page contexts. The JavaScript code <code>api</code> will be associated with <code>extension</code>. It should only be called during <code>XW_Initialize()</code>.</li>
<li><code>RegisterInstanceCallbacks()</code> informs the Crosswalk runtime of functions that should be called when new instances of the extension are created or destroyed. Instances have the same lifetime of the web content. This should only be called during <code>XW_Initialize()</code></li>
<li><code>RegisterShutdownCallback()</code> registers a callback that will be called when the extension is unloaded. This function should only be called during <code>XW_Initialize()</code>.</li>
<li><code>SetInstanceData()</code> and <code>GetInstanceData()</code> are convenience functions that allow for arbitrary data to be associated with each instance, and for that data to be retrieved. These functions may be called at any time during the lifecycle of an instance.</li>
</ul></li>
<li><p>Messaging interface: <code>XW_MESSAGING_INTERFACE</code></p>

<p>This interface is defined in the <a href="https://github.com/crosswalk-project/crosswalk/blob/master/extensions/public/XW_Extension.h">XW_Extension.h</a> header file.</p>

<p>It is a <code>struct XW_MessagingInterface</code> with the following fields:</p>

<ul><li>  <code>Register()</code>: when called, this function tells Crosswalk which function should be called in event of a message from the JavaScript side.</li>
<li>  <code>PostMessage()</code> sends a message to the web content associated with the <code>instance</code>.</li>
</ul></li>
<li><p>Sync messaging interface (experimental): <code>XW_INTERNAL_SYNC_MESSAGING_INTERFACE</code></p>

<p>This interface is defined in the <a href="https://github.com/crosswalk-project/crosswalk/blob/master/extensions/public/XW_Extension_SyncMessage.h">XW_Extension_SyncMessage.h</a> header file. It is marked as internal, and no guarantee will be made for its compatibility with future Crosswalk versions.</p>

<p>It is a <code>struct XW_Internal_SyncMessagingInterface</code> with the following fields:</p>

<ul><li>  <code>Register()</code>: this function tells Crosswalk which function should be called in event of a synchronous message from the JavaScript side.</li>
<li>  <code>SetSyncReply()</code> responds to a synchronous (blocking) message from the JavaScript side. The renderer process will be blocked until this function is called.rc/xwalk/extensions/public/*.h</li>
</ul></li>
</ul><p>The interface names and structures described above have a versioning suffix in their names. However, extension writers should use the unversioned macros to get the desired interfaces.</p>

<h2>Add build infrastructure<a class="anchor" id="Add-build-infrastructure" href="#Add-build-infrastructure"></a></h2>

<p>The build infrastructure enables generating an installable rpm package for your extension. This <code>.rpm</code> file can then be installed to the Tizen IVI target using the <code>rpm</code> package manager tool.</p>

<p>The files you need to add are:</p>

<ol><li><p>A <code>Makefile</code>. This is used to build the C program and output a shared library file <code>libecho.so</code>.</p>

<p>Note that the name is very important: it should begin with a "lib" prefix. Crosswalk will not load the extension correctly if it is called anything else.</p></li>
<li><p>An rpm spec file, <code>packaging/echo-extension.spec</code>. This file defines how the extension should be packaged and installed on the Tizen system.</p></li>
</ol><h3>Makefile<a class="anchor" id="Makefile" href="#Makefile"></a></h3>

<p>You can use a <code>Makefile</code> to invoke the compiler and generate the header file for the JavaScript API. In the project directory, add a file called <code>Makefile</code> with this content:</p>

<pre><code>ECHO_CFLAGS=$(CFLAGS) -fPIC -Wall

all: libecho.so

echo-extension.h:
    ./js2c.sh extension/api.js extension/echo-extension.h

libecho.so: prepare echo-extension.h
    $(CC) $(ECHO_CFLAGS) -shared -o build/libecho.so \
      $(SYSROOT_FLAGS) -Icommon extension/echo-extension.c

prepare:
    mkdir -p build

install: libecho.so
    install -D build/libecho.so \
      $(DESTDIR)/$(PREFIX)/lib/tizen-extensions-crosswalk/libecho.so

clean:
    rm -Rf build

.PHONY: all prepare clean
</code></pre>

<p>(As with all Makefiles, indent using tabs, rather than spaces.)</p>

<h3>RPM spec file<a class="anchor" id="RPM-spec-file" href="#RPM-spec-file"></a></h3>

<p>Crosswalk Tizen extensions should be packaged as rpm files. The structure and content of this rpm file is defined in an rpm <code>.spec</code> file. <code>gbs</code> uses this spec file to compile the extension against the Tizen IVI librarires; then generates an rpm compatible with a Tizen IVI target.</p>

<p>Create the spec file in <code>packaging/echo-extension.spec</code>, with this content:</p>

<pre><code>Name:     echo-extension
Version:  0.1
Release:  1
Summary:  Example Crosswalk Tizen extension
Group:    System/Libraries

License:    BSD-3-Clause
URL:      https://crosswalk-project.org/
Source0:  %{name}-%{version}.tar.gz

Requires: crosswalk

%description
Example Crosswalk Tizen extension which echoes any messages sent to it.

%prep
%setup -q

%build
make %{?_smp_mflags}

%install
make install DESTDIR=%{buildroot} PREFIX=%{_prefix}

%files
%{_prefix}/lib/tizen-extensions-crosswalk/libecho.so
</code></pre>

<p>Placing this file in the <code>packaging/</code> directory is important, as this is where <code>gbs</code> will expect to find a spec file for a project it's building.</p>

<p>The rpm spec file format is a complicated beast, and out of scope for this tutorial. If you want to learn more about it, see the <a href="http://rpm.org">RPM website</a>.</p>

<p>You should also be aware of the <a href="https://wiki.tizen.org/wiki/Packaging/Guidelines">Tizen packaging guidelines</a>, which explain best practices for writing spec files for Tizen packages.</p>

<h2>Run the build<a class="anchor" id="Run-the-build" href="#Run-the-build"></a></h2>

<p>Before running your build with <code>gbs</code>, make sure all your changes are committed to the local git repository:</p>

<pre><code>git add -A
git commit -m "Initial import"
</code></pre>

<p>To build the project using <code>gbs</code>, do:</p>

<pre><code>gbs -c ~/.gbs.conf build -A i586
</code></pre>

<p>Note that you're using the gbs configuration file in your home directory, so you're working with the correct Tizen IVI buildroot. It's also important that you set the architecture correctly with the <code>-A</code> option: the Tizen IVI images provided from the download site have <code>i586</code> architecture.</p>

<p>During the build, <code>gbs</code> will download the appropriate Tizen IVI packages, then compile and package your extension. The output <code>.rpm</code> files should end up in <code>/home/ell/GBS-ROOT/local/repos/tizen3.0/i586/RPMS</code> (unless you changed the gbs root location).</p>

<h1>Acknowledgements<a class="anchor" id="Acknowledgements" href="#Acknowledgements"></a></h1>

<p>Thanks to José Bollo for improvements to the <code>js2c.sh</code> script via <a href="https://lists.crosswalk-project.org/mailman/listinfo/crosswalk-help">crosswalk-dev</a>.</p>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>Romuald Texier-Marcadé</b>, 2014-07-15 15:47:10</p>
  <p>
    <a id="delete-link" href="/documentation/Tizen_IVI_extensions/15-Write_an_extension_in_C" data-confirm="Are you sure you want to delete this page?"><span>Delete this Page</span></a>
  </p>
</div>
</div>

<form name="rename" method="POST" action="/rename/documentation/Tizen_IVI_extensions/15-Write_an_extension_in_C">
  <input type="hidden" name="rename"/>
  <input type="hidden" name="message"/>
</form>


</body>
</html>
